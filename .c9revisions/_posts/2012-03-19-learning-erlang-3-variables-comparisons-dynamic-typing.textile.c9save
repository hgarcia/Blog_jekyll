{"ts":1349126038838,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"---\nlayout: post\ntitle: Variables, comparisons and dynamic typing. (Learning Erlang 3)\nsummary: Variables are immutables. Comparison can be performed between any type. Typing is dynamic and some data conversion is performed.\ncategories: [Programming, Erlang]\n---\n\n__Note of caution. These are my notes while learning Erlang. You are welcome to follow along and use them as a guide. Please make sure to check the \"Erlang language\":http://www.erlang.org site__\n\nVariables can only be bound once per scope. There is no such thing as global variables. (Great!)\nYou don't need to declare variables before hand, you just create and assign at the same time.\nVariables name need to start with an uppercase follow by any number of upper and lower case letters, numbers or the underscore, other characters are invalid.\n\n<script src=\"https://gist.github.com/2093388.js?file=variables.erl\"></script>\n\nSingle assignment means that variables are immutables.\n\n<script src=\"https://gist.github.com/2093388.js?file=variables_inmutables.erl\"></script>\n\nThe assignment is done by matching an unbound variable to any valid Erlang expression. The match is done using the equal sign. If the variable was previously bound we say that we are doing a test instead of an assignment.\n\nYou can assign multiple variables at once, just provide the right pattern.\n\n<script src=\"https://gist.github.com/2093388.js?file=multiple_assignments.erl\"></script>\n\nh3. Erlang goes dynamic.\n\nNot sure if this is true but apparently the reason Erlang use dynamic typing is because the guys that wrote the language originally, didn't know how to write a type system and subsequent attempts to doing so failed due to some design decisions in the language itself.\n\n__I really don't care at all why Erlang is dynamic. I think dynamic languages make things easier in 80% of the cases (maybe more). Ultimately that's what it is so just relax__\n\n<script src=\"https://gist.github.com/2093388.js?file=dynamic_typing.erl\"></script>\n\nh3. One of these things.\n\n__\"One of these things\":http://muppet.wikia.com/wiki/One_of_These_Things Muppets wiki__\n\nTaking decisions sometimes can overwhelm us, simple human beens, but computers are cold in their binary logic. Let's see how Erlang compare values.\n\nh4. Equality\n\n<script src=\"https://gist.github.com/2094463.js?file=equal.erl\"></script>\n\nNotice lines 8 and 9, the double equal will check for equality but doing some type conversion. If you want strict equality use the equal colon equal operator instead.\n\nh4. Inequality\n\nAs with equality there is a not equal and a exactly non equal operator.\n\n<script src=\"https://gist.github.com/2094463.js?file=not_equal.erl\"></script>\n\nh4. More, less, more or equal, less or equal.\n\nNothing strange here, just the less or equal symbol is actually equal or less.\n\n<script src=\"https://gist.github.com/2094463.js?file=more_and_less.erl\"></script>\n\nComparing between numbers, lists, atoms and tuples can be done using the same operators.\n\n<script src=\"https://gist.github.com/2094463.js?file=comparing_types.erl\"></script>\n\nWhen comparing different types the following is taking in consideration:\n\n* number are less than atom\n* atom are less than reference\n* reference are less than func\n* func are less than port\n* port are less than pid\n* pid are less than tuple\n* tuple are less than list\n* list are less than binary\n\nTuples are compared first by the number of elements contained and secondly each element is compared in turn.\n"]],"start1":0,"start2":0,"length1":0,"length2":3460}]],"length":3460}
